-- Public functions

CREATE LANGUAGE plperl;

BEGIN;

CREATE FUNCTION set_modified () RETURNS "trigger" AS $$
BEGIN
	NEW.created = OLD.created;
	NEW.modified = now();
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

-- jet schema

CREATE SCHEMA jet;

SET search_path TO jet;

CREATE TABLE engine (
	id						serial NOT NULL PRIMARY KEY,
	name					text UNIQUE,
	recipe					text,
	created					timestamp default now(),
	modified				timestamp
);

COMMENT ON TABLE engine IS 'Jet Engine';
COMMENT ON COLUMN engine.name IS 'Engine Name';
COMMENT ON COLUMN engine.recipe IS 'Ingredients and steps for cooking a node';

CREATE TRIGGER set_modified BEFORE UPDATE ON engine FOR EACH ROW EXECUTE PROCEDURE public.set_modified();


CREATE TABLE basetype (
	id						serial NOT NULL PRIMARY KEY,
	name					text UNIQUE,
	parent					int[],
	columns					json,
	searchable				text[],
	engines					int[], -- REFERENCES engine
	conditions				text,
	bindings				text,
	created					timestamp default now(),
	modified				timestamp
);

COMMENT ON TABLE basetype IS 'Node Base Type';
COMMENT ON COLUMN basetype.name IS 'Base Name';
COMMENT ON COLUMN basetype.parent IS 'Array of allowed parent basetypes';
COMMENT ON COLUMN basetype.conditions IS 'All conditions for the recipe of this basetype';
COMMENT ON COLUMN basetype.bindings IS 'All parts for the recipe of this basetype';
COMMENT ON COLUMN basetype.columns IS 'The column definition';

CREATE TRIGGER set_modified BEFORE UPDATE ON basetype FOR EACH ROW EXECUTE PROCEDURE public.set_modified();

CREATE TABLE data (
	id						serial NOT NULL PRIMARY KEY,
	basetype_id				int NOT NULL REFERENCES basetype(id)
							ON DELETE restrict
							ON UPDATE restrict,
	name					text,
	title					text,
	columns					text[],
	fts						tsvector,
	created					timestamp default now(),
	modified				timestamp
);

COMMENT ON TABLE data IS 'Data';
COMMENT ON COLUMN data.basetype_id IS 'The Basetype of the Data';
COMMENT ON COLUMN data.name IS 'The name';
COMMENT ON COLUMN data.title IS 'The Title';
COMMENT ON COLUMN data.columns IS 'The actual column data';
COMMENT ON COLUMN data.fts IS 'Full Text Search column containing the content of the searchable columns';

CREATE TRIGGER set_modified BEFORE UPDATE ON data FOR EACH ROW EXECUTE PROCEDURE public.set_modified();

CREATE TABLE node (
	id						serial NOT NULL PRIMARY KEY,
	data_id					int REFERENCES data(id)
							ON DELETE cascade
							ON UPDATE cascade,
	parent_id				int REFERENCES node(id)
							ON DELETE cascade
							ON UPDATE cascade,
	part					text,
	node_path				text UNIQUE,
	created					timestamp default now(),
	modified				timestamp
);

COMMENT ON TABLE node IS 'Node';
COMMENT ON COLUMN node.parent_id IS 'Pointer to the data row';
COMMENT ON COLUMN node.parent_id IS 'Parent of this uri';
COMMENT ON COLUMN node.part IS 'Path part';
COMMENT ON COLUMN node.node_path IS 'Global Path parts';

CREATE TRIGGER set_modified BEFORE UPDATE ON node FOR EACH ROW EXECUTE PROCEDURE public.set_modified();

--
-- data_node view
--

CREATE VIEW data_node AS
SELECT d.id data_id, d.basetype_id, d.name, d.title, d.columns, d.fts, d.created data_created, d.modified data_modified,
	n.id node_id, n.parent_id, n.part, n.node_path, n.created node_created, n.modified	node_modified
FROM jet.data d
JOIN jet.node n ON d.id=n.data_id;

CREATE OR REPLACE FUNCTION data_node_insert() RETURNS trigger AS $$
DECLARE
BEGIN
	WITH new_data AS (
		INSERT INTO jet.data (basetype_id, name, title, columns, fts) VALUES (NEW.basetype_id, NEW.name, NEW.title, NEW.columns, NEW.fts) RETURNING id
	)
	INSERT INTO jet.node (data_id, parent_id, part, node_path) SELECT id, NEW.parent_id, NEW.part, NEW.node_path FROM new_data;
	RETURN NEW;
END;
$$ language plpgsql;

CREATE TRIGGER data_node_insert INSTEAD OF INSERT ON data_node FOR EACH ROW EXECUTE PROCEDURE jet.data_node_insert();

CREATE OR REPLACE FUNCTION data_node_update() RETURNS trigger AS $$
DECLARE
BEGIN
	UPDATE jet.data
		SET basetype_id=NEW.basetype_id, name=NEW.name, title=NEW.title, columns=NEW.columns, fts=NEW.fts
		WHERE id=OLD.data_id;
	UPDATE jet.node
		SET parent_id=NEW.parent_id, part=NEW.part, node_path=NEW.node_path
		WHERE id=OLD.node_id;
	RETURN NEW;
END;
$$ language plpgsql;

CREATE TRIGGER data_node_update INSTEAD OF UPDATE ON data_node FOR EACH ROW EXECUTE PROCEDURE jet.data_node_update();

-- --------------------------------------------------------------------
-- A hierarchical data (tree) implementation using triggers
-- inside the database as described here:
--
--   http://www.depesz.com/index.php/2008/04/11/my-take-on-trees-in-sql/
--
-- Generated by sqltree on Wed Apr  4 20:34:19 2012 for Pg
-- --------------------------------------------------------------------

DROP TABLE IF EXISTS node_tree;

DROP TRIGGER IF EXISTS node_tree_insert_trigger_1 ON node;

DROP TRIGGER IF EXISTS node_tree_before_update_trigger_1 ON node;

DROP TRIGGER IF EXISTS node_tree_after_update_trigger_1 ON node;

DROP TRIGGER IF EXISTS node_tree_path_before_update_trigger ON node;

CREATE OR REPLACE FUNCTION make_plpgsql()
RETURNS VOID
LANGUAGE SQL
AS $$
CREATE LANGUAGE plpgsql;
$$;

SELECT
    CASE
    WHEN EXISTS(
        SELECT 1
        FROM pg_catalog.pg_language
        WHERE lanname='plpgsql'
    )
    THEN NULL
    ELSE make_plpgsql()
    END;

DROP FUNCTION make_plpgsql();

CREATE TABLE node_tree (
    treeid    SERIAL PRIMARY KEY,
    parent    int NOT NULL REFERENCES node(id) ON DELETE CASCADE,
    child     int NOT NULL REFERENCES node(id) ON DELETE CASCADE,
    depth     INTEGER NOT NULL,
    UNIQUE (parent, child)
);

--
-- Find a complete branch in the nodetree
--

CREATE OR REPLACE VIEW data_node_acl AS (
	SELECT d.*, a.acl
	FROM data_node d
	LEFT JOIN (
		SELECT d.node_id, array_agg(array_to_string(p.columns, ',')) acl
		FROM data_node d
		JOIN jet.node_tree n ON d.node_id=n.child
		JOIN jet.data_node p ON n.parent=p.node_id
		JOIN jet.basetype b ON p.basetype_id=b.id
		AND b.name='acl'
		GROUP BY d.node_id
	) a USING (node_id)
);

CREATE OR REPLACE FUNCTION find_nodebranch(path text) RETURNS SETOF data_node_acl
	LANGUAGE plpgsql
	AS $$
DECLARE
	parts text[];
	item text;
	build_part text;
	paths text[];
BEGIN
	parts := regexp_split_to_array(path, E'\/+');
	FOREACH item IN ARRAY parts LOOP
		paths := array_append(paths, array_to_string(ARRAY[paths[array_length(paths, 1)], item], '/'));
	END LOOP;
	RETURN QUERY SELECT *
		FROM jet.data_node_acl
		WHERE node_path = ANY (paths)
		ORDER BY length(node_path) DESC;
END;
$$;

-- --------------------------------------------------------------------
-- INSERT:
-- 1. Insert a matching row in node_tree where both parent and child
-- are set to the id of the newly inserted object. Depth is set to 0 as
-- both child and parent are on the same level.
--
-- 2. Copy all rows that our parent had as its parents, but we modify
-- the child id in these rows to be the id of currently inserted row,
-- and increase depth by one.
-- --------------------------------------------------------------------
CREATE OR REPLACE FUNCTION ai_node_tree_1() RETURNS TRIGGER AS
$BODY$
DECLARE
BEGIN
    INSERT INTO jet.node_tree (parent, child, depth)
        VALUES (NEW.id, NEW.id, 0);
    INSERT INTO jet.node_tree (parent, child, depth)
        SELECT x.parent, NEW.id, x.depth + 1
            FROM jet.node_tree x
            WHERE x.child = NEW.parent_id;
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER ai_node_tree_1 AFTER INSERT ON node
FOR EACH ROW EXECUTE PROCEDURE ai_node_tree_1();

-- --------------------------------------------------------------------
-- UPDATE:
-- --------------------------------------------------------------------
-- As for moving data around in node freely, we should forbid
-- moves that would create loops:
CREATE OR REPLACE FUNCTION bu_node_tree_1() RETURNS TRIGGER AS
$BODY$
DECLARE
BEGIN
    IF NEW.id <> OLD.id THEN
        RAISE EXCEPTION 'Changing ids is forbidden.';
    END IF;
    IF OLD.parent_id IS NOT DISTINCT FROM NEW.parent_id THEN
        RETURN NEW;
    END IF;
    IF NEW.parent_id IS NULL THEN
        RETURN NEW;
    END IF;
    PERFORM 1 FROM jet.node_tree
        WHERE ( parent, child ) = ( NEW.id, NEW.parent_id );
    IF FOUND THEN
        RAISE EXCEPTION 'Update blocked, because it would create loop in tree.';
    END IF;
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER bu_node_tree_1 BEFORE UPDATE ON node
FOR EACH ROW EXECUTE PROCEDURE bu_node_tree_1();

CREATE OR REPLACE FUNCTION au_node_tree_1() RETURNS TRIGGER AS
$BODY$
DECLARE
BEGIN
    IF OLD.parent_id IS NOT DISTINCT FROM NEW.parent_id THEN
        RETURN NEW;
    END IF;
    IF OLD.parent_id IS NOT NULL THEN
        DELETE FROM jet.node_tree WHERE treeid in (
            SELECT r2.treeid
            FROM jet.node_tree r1
            JOIN jet.node_tree r2 ON r1.child = r2.child
            WHERE r1.parent = NEW.id AND r2.depth > r1.depth
        );
    END IF;
    IF NEW.parent_id IS NOT NULL THEN
        INSERT INTO jet.node_tree (parent, child, depth)
            SELECT r1.parent, r2.child, r1.depth + r2.depth + 1
            FROM
                jet.node_tree r1,
                jet.node_tree r2
            WHERE
                r1.child = NEW.parent_id AND
                r2.parent = NEW.id;
    END IF;
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER au_node_tree_1 AFTER UPDATE ON node
FOR EACH ROW EXECUTE PROCEDURE au_node_tree_1();



-- Generate path urls based on part and position in
-- the tree.
CREATE OR REPLACE FUNCTION bi_node_path_1()
RETURNS TRIGGER AS
$BODY$
DECLARE
BEGIN
    IF NEW.parent_id IS NULL THEN
        NEW.node_path := NEW.part;
    ELSE
        SELECT node_path || '/' || NEW.part INTO NEW.node_path
        FROM jet.node
        WHERE id = NEW.parent_id;
    END IF;
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER bi_node_path_1 BEFORE INSERT ON node
FOR EACH ROW EXECUTE PROCEDURE bi_node_path_1();

CREATE OR REPLACE FUNCTION bu_node_path_1()
RETURNS TRIGGER AS
$BODY$
DECLARE
    replace_from TEXT := '^';
    replace_to   TEXT := '';
BEGIN
    IF OLD.parent_id IS NOT DISTINCT FROM NEW.parent_id AND OLD.part IS NOT DISTINCT FROM NEW.part THEN
        RETURN NEW;
    END IF;
    IF OLD.part IS DISTINCT FROM NEW.part THEN
        SELECT node_path || '/' || NEW.part INTO NEW.node_path
        FROM jet.node
        WHERE id = NEW.parent_id;
    END IF;
    IF OLD.parent_id IS NOT NULL THEN
        SELECT '^' || node_path || '/' INTO replace_from
        FROM jet.node
        WHERE id = OLD.parent_id;
    END IF;
    IF NEW.parent_id IS NOT NULL THEN
        SELECT node_path || '/' INTO replace_to
        FROM jet.node
        WHERE id = NEW.parent_id;
    END IF;
    NEW.node_path := regexp_replace( NEW.node_path, replace_from, replace_to );
    replace_from := replace_from || OLD.part;
    replace_to := replace_to || NEW.part;
    UPDATE jet.node
    SET node_path = regexp_replace(node_path, replace_from, replace_to )
    WHERE id in (
        SELECT child
        FROM jet.node_tree
        WHERE parent = NEW.id AND depth > 0
    );
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER bu_node_path_1 BEFORE UPDATE ON node
FOR EACH ROW EXECUTE PROCEDURE bu_node_path_1();


CREATE OR REPLACE FUNCTION connect_nodes(parent int, child int) RETURNS VOID
	LANGUAGE plpgsql
	AS $$
BEGIN
	INSERT INTO jet.node_tree (parent, child, depth) VALUES (parent,child,0);
	RETURN ;
END;
$$;

COMMIT;