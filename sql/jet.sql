-- Public functions

CREATE LANGUAGE plperl;

BEGIN;

CREATE FUNCTION set_modified () RETURNS "trigger" AS $$
BEGIN
	NEW.created = OLD.created;
	NEW.modified = now();
	RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

-- jet schema

CREATE SCHEMA jet;

SET search_path TO jet;

CREATE TABLE basetype (
	id						serial NOT NULL PRIMARY KEY,
	name					text UNIQUE,
	parent					int[],
	columns					text[],
	searchable				text[],
	recipe					text,
	created					timestamp default now(),
	modified				timestamp
);

COMMENT ON TABLE basetype IS 'Node Base Type';
COMMENT ON COLUMN basetype.name IS 'Base Name';
COMMENT ON COLUMN basetype.parent IS 'Array of allowed parent basetypes';
COMMENT ON COLUMN basetype.columns IS 'The column definition';
COMMENT ON COLUMN basetype.recipe IS 'Ingredients and steps for cooking a node';

CREATE TRIGGER set_modified BEFORE UPDATE ON basetype FOR EACH ROW EXECUTE PROCEDURE public.set_modified();

CREATE TABLE node (
	id						serial NOT NULL PRIMARY KEY,
	basetype_id				int NOT NULL REFERENCES basetype(id)
							ON DELETE restrict
							ON UPDATE restrict,
	parent_id				int REFERENCES node(id)
							ON DELETE cascade
							ON UPDATE cascade,
	part					text,
	node_path				text UNIQUE,
	name					text,
	title					text,
	columns					text[],
	fts						tsvector,
	created					timestamp default now(),
	modified				timestamp
);

COMMENT ON TABLE node IS 'Node';
COMMENT ON COLUMN node.basetype_id IS 'The Basetype of the Node';
COMMENT ON COLUMN node.parent_id IS 'Parent of this uri';
COMMENT ON COLUMN node.part IS 'Path part';
COMMENT ON COLUMN node.node_path IS 'Global Path parts';
COMMENT ON COLUMN node.name IS 'The Node''s name';
COMMENT ON COLUMN node.title IS 'The Node Title';
COMMENT ON COLUMN basetype.columns IS 'The actual column data';
COMMENT ON COLUMN node.fts IS 'Full Text Search column containing the content of the searchable columns';

CREATE TRIGGER set_modified BEFORE UPDATE ON node FOR EACH ROW EXECUTE PROCEDURE public.set_modified();

-- Functions

CREATE OR REPLACE FUNCTION update_fts() RETURNS trigger AS $$
	# jet.basetype
	my $q = "SELECT * FROM jet.basetype WHERE id = $_TD->{new}{basetype_id}";
	my $rv = spi_exec_query($q);
	unless ($rv->{status} eq 'SPI_OK_SELECT' and $rv->{processed} == 1) {
		elog(ERROR,"Basetype $base_name not found in jet.basetype");
		return SKIP;
	}

	my $base_row = $rv->{rows}->[0];
	my $base_columns = $base_row->{columns};
	my $searchable = $base_row->{searchable};
	return MODIFY unless @{ $base_columns } and @{ $searchable };

	my @datacols = @{ $_TD->{new}{columns} };
	my ($columns, $fts);
	$columns->{$_} = shift @datacols for @{ $base_columns };
	$fts = join ' ', map {$columns->{$_}} grep {$columns->{$_}} @$searchable; # Find searchable columns with content
	$_TD->{new}{fts} = $fts;
	return MODIFY;
$$
LANGUAGE 'plperl' VOLATILE;

CREATE TRIGGER update_fts BEFORE INSERT OR UPDATE ON node FOR EACH ROW EXECUTE PROCEDURE jet.update_fts();

--
-- Check that a row has the correct parent type
--

CREATE OR REPLACE FUNCTION trig_check_basetype() RETURNS trigger AS
$$
DECLARE
	parent_array int[];
	parent_type int;
BEGIN
	IF new.parent_id IS NULL THEN
		RETURN NEW;
	END IF;
	SELECT parent INTO parent_array FROM jet.basetype WHERE id = NEW.basetype_id;
	IF parent_array IS NULL THEN
		RETURN NEW;
	END IF;
	SELECT basetype_id INTO parent_type FROM jet.node WHERE id = NEW.parent_id;
	IF parent_type = ANY (parent_array) THEN
		RETURN NEW;
	ELSE
		RAISE INFO 'Can''t insert child type % under parent %', NEW.parent_id, parent_type;
		RETURN NULL;
	END IF;
END
$$
LANGUAGE 'plpgsql' VOLATILE;

-- Path triggers

-- for postgreSQL 9.0 -- you can use this syntax to save unnecessary check of trigger function
CREATE TRIGGER
	trig01_check_basetype
AFTER INSERT OR UPDATE OF
	parent_id
ON
	node
FOR EACH ROW EXECUTE PROCEDURE
	trig_check_basetype();


-- --------------------------------------------------------------------
-- A hierarchical data (tree) implementation using triggers
-- inside the database as described here:
--
--   http://www.depesz.com/index.php/2008/04/11/my-take-on-trees-in-sql/
--
-- Generated by sqltree on Wed Apr  4 20:34:19 2012 for Pg
-- --------------------------------------------------------------------

DROP TABLE IF EXISTS node_tree;

DROP TRIGGER IF EXISTS node_tree_insert_trigger_1 ON node;

DROP TRIGGER IF EXISTS node_tree_before_update_trigger_1 ON node;

DROP TRIGGER IF EXISTS node_tree_after_update_trigger_1 ON node;

DROP TRIGGER IF EXISTS node_tree_path_before_update_trigger ON node;

CREATE OR REPLACE FUNCTION make_plpgsql()
RETURNS VOID
LANGUAGE SQL
AS $$
CREATE LANGUAGE plpgsql;
$$;

SELECT
    CASE
    WHEN EXISTS(
        SELECT 1
        FROM pg_catalog.pg_language
        WHERE lanname='plpgsql'
    )
    THEN NULL
    ELSE make_plpgsql()
    END;

DROP FUNCTION make_plpgsql();

CREATE TABLE node_tree (
    treeid    SERIAL PRIMARY KEY,
    parent    int NOT NULL REFERENCES node(id) ON DELETE CASCADE,
    child     int NOT NULL REFERENCES node(id) ON DELETE CASCADE,
    depth     INTEGER NOT NULL,
    UNIQUE (parent, child)
);

-- --------------------------------------------------------------------
-- INSERT:
-- 1. Insert a matching row in node_tree where both parent and child
-- are set to the id of the newly inserted object. Depth is set to 0 as
-- both child and parent are on the same level.
--
-- 2. Copy all rows that our parent had as its parents, but we modify
-- the child id in these rows to be the id of currently inserted row,
-- and increase depth by one.
-- --------------------------------------------------------------------
CREATE OR REPLACE FUNCTION ai_node_tree_1() RETURNS TRIGGER AS
$BODY$
DECLARE
BEGIN
    INSERT INTO jet.node_tree (parent, child, depth)
        VALUES (NEW.id, NEW.id, 0);
    INSERT INTO jet.node_tree (parent, child, depth)
        SELECT x.parent, NEW.id, x.depth + 1
            FROM jet.node_tree x
            WHERE x.child = NEW.parent_id;
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER ai_node_tree_1 AFTER INSERT ON node
FOR EACH ROW EXECUTE PROCEDURE ai_node_tree_1();

-- --------------------------------------------------------------------
-- UPDATE:
-- --------------------------------------------------------------------
-- As for moving data around in node freely, we should forbid
-- moves that would create loops:
CREATE OR REPLACE FUNCTION bu_node_tree_1() RETURNS TRIGGER AS
$BODY$
DECLARE
BEGIN
    IF NEW.id <> OLD.id THEN
        RAISE EXCEPTION 'Changing ids is forbidden.';
    END IF;
    IF OLD.parent_id IS NOT DISTINCT FROM NEW.parent_id THEN
        RETURN NEW;
    END IF;
    IF NEW.parent_id IS NULL THEN
        RETURN NEW;
    END IF;
    PERFORM 1 FROM jet.node_tree
        WHERE ( parent, child ) = ( NEW.id, NEW.parent_id );
    IF FOUND THEN
        RAISE EXCEPTION 'Update blocked, because it would create loop in tree.';
    END IF;
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER bu_node_tree_1 BEFORE UPDATE ON node
FOR EACH ROW EXECUTE PROCEDURE bu_node_tree_1();

CREATE OR REPLACE FUNCTION au_node_tree_1() RETURNS TRIGGER AS
$BODY$
DECLARE
BEGIN
    IF OLD.parent_id IS NOT DISTINCT FROM NEW.parent_id THEN
        RETURN NEW;
    END IF;
    IF OLD.parent_id IS NOT NULL THEN
        DELETE FROM jet.node_tree WHERE treeid in (
            SELECT r2.treeid
            FROM jet.node_tree r1
            JOIN jet.node_tree r2 ON r1.child = r2.child
            WHERE r1.parent = NEW.id AND r2.depth > r1.depth
        );
    END IF;
    IF NEW.parent_id IS NOT NULL THEN
        INSERT INTO jet.node_tree (parent, child, depth)
            SELECT r1.parent, r2.child, r1.depth + r2.depth + 1
            FROM
                jet.node_tree r1,
                jet.node_tree r2
            WHERE
                r1.child = NEW.parent_id AND
                r2.parent = NEW.id;
    END IF;
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER au_node_tree_1 AFTER UPDATE ON node
FOR EACH ROW EXECUTE PROCEDURE au_node_tree_1();



-- Generate path urls based on part and position in
-- the tree.
CREATE OR REPLACE FUNCTION bi_node_path_1()
RETURNS TRIGGER AS
$BODY$
DECLARE
BEGIN
    IF NEW.parent_id IS NULL THEN
        NEW.node_path := NEW.part;
    ELSE
        SELECT node_path || '/' || NEW.part INTO NEW.node_path
        FROM jet.node
        WHERE id = NEW.parent_id;
    END IF;
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER bi_node_path_1 BEFORE INSERT ON node
FOR EACH ROW EXECUTE PROCEDURE bi_node_path_1();

CREATE OR REPLACE FUNCTION bu_node_path_1()
RETURNS TRIGGER AS
$BODY$
DECLARE
    replace_from TEXT := '^';
    replace_to   TEXT := '';
BEGIN
    IF OLD.parent_id IS NOT DISTINCT FROM NEW.parent_id THEN
        RETURN NEW;
    END IF;
    IF OLD.parent_id IS NOT NULL THEN
        SELECT '^' || node_path || '/' INTO replace_from
        FROM jet.node
        WHERE id = OLD.parent_id;
    END IF;
    IF NEW.parent_id IS NOT NULL THEN
        SELECT node_path || '/' INTO replace_to
        FROM jet.node
        WHERE id = NEW.parent_id;
    END IF;
    NEW.node_path := regexp_replace( NEW.node_path, replace_from, replace_to );
    UPDATE jet.node
    SET node_path = regexp_replace(node_path, replace_from, replace_to )
    WHERE id in (
        SELECT child
        FROM jet.node_tree
        WHERE parent = NEW.id AND depth > 0
    );
    RETURN NEW;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER bu_node_path_1 BEFORE UPDATE ON node
FOR EACH ROW EXECUTE PROCEDURE bu_node_path_1();

COMMIT;