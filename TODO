Best Practices
--------------
namespace::autoclean

Template searching
------------------
- templates/basetypes
- Standard templates in Jet with File::ShareDir
- Set path as e.g. Text::Xslate->new( path => \@path );

Stash
-----
- node
  - row
  - basetype

Relations
---------
$node->children						all children
$node->children('basetype')			all children with that basetype
$node->children([qw/type1 type2])	more basetypes
$node->children('basetype', $opt)	with options

$node->parent						most nodes have only one parent
$node->parent						all parents
$node->parents('basetype')			all parents with that basetype
$node->parents([qw/type1 type2])	more basetypes
$node->parents('basetype', $opt)	with options

$opt
	order_by
	limit

REST
----
- Init: Examine headers. accept_content_type.
  Set context->rest->accept_types (arrayref)
  Set context->rest->type (no 1 from accepted list)
- Process: ability to check or set context->rest->type
  Some processing depens on REST type
- Response render: Find the renderer from context->rest->type

Search
------
- PostgreSQL FTS
  A tsvector column on jet.node
- Checkbox for a column: "searchable"
  If checked, a fts column on the node is updated with this column's content.
- Insert, update triggers on _view
  loop through searchable and update fts
  Only update if there has been any change in the seachable columns
- http://search.cpan.org/dist/Search-Tools/

Transactions
------------
- Specify a way to start / commit / abort transactions
  Perhaps just a transaction plugin

Caching
-------
- Mark page as cachable
  Render first time
  Get from cache and compare expiration time

Jet Schema
----------
- basetype
  pathmatch - a regex to match the endpath (see Jet.pm)
  templatename - relative/absolute?
  response types we can/can't handle
  "traits" like menu, breadcrumbs for each REST type
- node
  cache time (interval)
- update, delete data_view triggers

Engine class
------------
- delete, update
- clean out unused methods

Result class
------------
- Row maker - insert column accessors
  Perhaps use cases from some other classses
  Moose::Meta::Class->create_anon_class 
  then $meta->add_attribute for each column
  then cache the result of that so you don't do it again next time you run the same query

Plack
-----
- Authentication
  http://search.cpan.org/dist/Plack-Middleware-Auth-Form/
  ACL for images still a problem
- Image handling
  http://search.cpan.org/dist/Plack-Middleware-Image-Scale/

Modules
-------
- Jet::Config -> Jet::Context::Config

File Upload
-----------
- Plack::Request::Upload
  my $upload = $req->uploads->{field};
  path - temporary file
  content_type
  filename - original filename

Plugins
-------
- Upload -> File::Upload
  Refactor hash directory handling
  Config option for base dir
- Packaging
  The plugins themselves
  basetype definitions - including recipes - and a script to insert them into the database
- Admin
  Administration should just be another plugin
  Or perhaps a recipe with several plugins

Recipes
-------
- Ingredients list and procedure (steps)
  Ingredient list: Mapping of external data to the requirement of the plugins
- Readd recipe to jet.basetypes.
  As a json for now
- On startup, Look through all jet.basetypes and 'compile' the recipes
  require the plugin modules
  name the recipe
  cache the recipe in context->recipes
  A load or register method to init the plugin methods

Data Repository
---------------
- Define Moose base types
  Perl/Moose <-> PostgreSQL mapping
  Data representation(s)
  - html pages
  - lists
  - etc
- Define nodes
  Add "fields" from base types
  DDL to create tables in the data schema
  DDL to add/update /delete columns when fields change
- Will make it possible/easier to make a row maker

Testing
-------
- Test database creation
  Use Family::Photo schema
- path creation
  move a node, see the path change ripple through the tree
  update/delete a leaf node, a stem node, a root node
- Coverage is low
- Coverate report
- POD coverage
