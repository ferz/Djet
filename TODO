Best Practices
--------------
namespace::autoclean

Template searching
------------------
- templates/basetypes
- Standard templates in Jet with File::ShareDir
- Set path as e.g. Text::Xslate->new( path => \@path );
- Should probably be by type in config file
  template
    html
      path
      suffix

Stash
-----
- node
  - row
  - basetype

Relations
---------
$node->children 										all children
$node->children('basetype')						all children with that basetype
$node->children([qw/type1 type2])			more basetypes
$node->children('basetype', $opt)			with options

$node->parent											most nodes have only one parent
$node->parent											all parents
$node->parents('basetype')						all parents with that basetype
$node->parents([qw/type1 type2])			more basetypes
$node->parents('basetype', $opt)				with options

$node->descendants									all descendants
$node->descendants('basetype')				all descendants with that basetype
$node->descendants([qw/type1 type2])	more basetypes
$node->descendants('basetype', $opt)		with options

$opt
	order_by
	limit
	offset

$node->descendants uses PostgreSQL's WITH RECURSIVE-construct

There might be a case for choosing between returning Jet::Engine::Result and an array of Jet::Node
Or refactor (and rename) Jet::Engine::Result to return an array of Jet::Engine::Row or Jet::Node;

REST
----
- Init: Examine headers. accept_content_type.
  Set context->rest->accept_types (arrayref)
  Set context->rest->type (no 1 from accepted list)
  Set context->rest->content if there's something to deserialize
- Process: ability to check or set context->rest->type
  Some processing depens on REST type
- Response render: Find the renderer from context->rest->type

Search
------
- PostgreSQL FTS
  A tsvector column on jet.node
  fts should be combinable with ACL for searching, so the search result should reflect the user's permissions
- Checkbox for a column: "searchable"
  If checked, a fts column on the node is updated with this column's content.
- Insert, update triggers on _view
  loop through searchable and update fts
  Only update if there has been any change in the seachable columns
- http://search.cpan.org/dist/Search-Tools/

Paging
------
- limit, offset
- CPAN module?
- http://wiki.postgresql.org/wiki/Count_estimate

Transactions
------------
- Specify a way to start / commit / abort transactions
  Perhaps just a transaction plugin

Caching
-------
- Mark page as cachable
  Render first time
  Get from cache and compare expiration time

Jet Schema
----------
- basetype
  pathmatch - a regex to match the endpath (see Jet.pm)
  templatename - relative/absolute?
  response types we can/can't handle
  "traits" like menu, breadcrumbs for each REST type
- path
  Perhaps active flag, active period(s) - or publish time, expiration time
  Problem with this is to find out when to apply
  - For all children?
  - In all cases?
- node
  cache time (interval)
- update, delete data_view triggers
- Trash
  Some way to delete a tree by moving it to a "Trash" node.
  There could be more than one node with the same path part

Engine class
------------
- delete, update
- clean out unused methods

Result class
------------
- Row maker - insert column accessors
  Perhaps use cases from some other classses
  Moose::Meta::Class->create_anon_class 
  then $meta->add_attribute for each column
  then cache the result of that so you don't do it again next time you run the same query

Node class
----------
- children (etc)
  search can be optimized for the different scenarios
  right now there's a select for each child even when the search could be smarter

Plack
-----
- Authentication
  http://search.cpan.org/dist/Plack-Middleware-Auth-Form/
  ACL for images still a problem
- Image handling
  http://search.cpan.org/dist/Plack-Middleware-Image-Scale/

Modules
-------
- Jet::Config -> Jet::Context::Config

File Upload
-----------
- Plack::Request::Upload
  my $upload = $req->uploads->{field};
  path - temporary file
  content_type
  filename - original filename

Plugins
-------
- Upload -> File::Upload
  Refactor hash directory handling
  Config option for base dir
- Packaging
  The plugins themselves
  basetype definitions - including recipes - and a script to insert them into the database
- Admin
  Administration should just be another plugin
  Or perhaps a recipe with several plugins

Recipes
-------
- Ingredients list and procedure (steps)
  Ingredient list: Mapping of external data to the requirement of the plugins
- Readd recipe to jet.basetypes.
  As a json for now
- On startup, Look through all jet.basetypes and 'compile' the recipes
  require the plugin modules
  name the recipe
  cache the recipe in context->recipes
  A load or register method to init the plugin methods

Data Repository
---------------
- Define Moose base types
  Perl/Moose <-> PostgreSQL mapping
  Data representation(s)
  - html pages
  - lists
  - etc
- Define nodes
  Add "fields" from base types
  DDL to create tables in the data schema
  DDL to add/update /delete columns when fields change
- Will make it possible/easier to make a row maker

Testing
-------
- Test database creation
  Use Family::Photo schema
- path creation
  move a node, see the path change ripple through the tree
  update/delete a leaf node, a stem node, a root node
- Coverage is low
- Coverate report
- POD coverage
- Test plugins 

Logging
-------

Statistics
----------

Devel mode
----------
- Optionally turn on/off some features when developing
  Text::Xslate cache